"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyboardProvider = exports.defaultKeyboardValues = exports.defaultKeyboardContext = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _KeyboardContext = require("./KeyboardContext");

var _en = _interopRequireDefault(require("../translation/en"));

var _emojis = _interopRequireDefault(require("../assets/emojis.json"));

var _useKeyboardStore = require("../store/useKeyboardStore");

var _types = require("../types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defaultKeyboardContext = {
  open: false,
  onClose: () => {},
  onEmojiSelected: _emoji => {},
  emojiSize: 28,
  containerStyles: {},
  knobStyles: {},
  headerStyles: {},
  expandable: true,
  hideHeader: false,
  defaultHeight: '40%',
  expandedHeight: '80%',
  backdropColor: '#00000055',
  categoryColor: '#000000',
  activeCategoryColor: '#005b96',
  categoryContainerColor: '#e3dbcd',
  activeCategoryContainerColor: '#ffffff',
  onCategoryChangeFailed: info => {
    console.warn(info);
  },
  translation: _en.default,
  disabledCategories: [],
  enableRecentlyUsed: false,
  categoryPosition: 'floating',
  enableSearchBar: false,
  closeSearchColor: '#00000055',
  searchBarStyles: {},
  searchBarTextStyles: {},
  searchBarPlaceholderColor: '#00000055',
  categoryOrder: [..._types.CATEGORIES],
  onRequestClose: () => {},
  categoryContainerStyles: {},
  disableSafeArea: false
};
exports.defaultKeyboardContext = defaultKeyboardContext;
const defaultKeyboardValues = {
  activeCategoryIndex: 0,
  setActiveCategoryIndex: () => {},
  numberOfColumns: 5,
  width: 0,
  searchPhrase: '',
  setSearchPhrase: _phrase => {},
  renderList: []
};
exports.defaultKeyboardValues = defaultKeyboardValues;
const KeyboardProvider = /*#__PURE__*/React.memo(props => {
  const {
    width
  } = (0, _reactNative.useWindowDimensions)();
  const [activeCategoryIndex, setActiveCategoryIndex] = React.useState(0);
  const [searchPhrase, setSearchPhrase] = React.useState('');
  const {
    keyboardState
  } = (0, _useKeyboardStore.useKeyboardStore)();
  const numberOfColumns = React.useRef(Math.floor(width / ((props.emojiSize ? props.emojiSize : defaultKeyboardContext.emojiSize) * 2)));
  React.useEffect(() => {
    if (props.open) setActiveCategoryIndex(0);
    setSearchPhrase('');
  }, [props.open]);
  const renderList = React.useMemo(() => {
    let data = _emojis.default.filter(category => {
      const title = category.title;
      if (props.disabledCategories) return !props.disabledCategories.includes(title);
      return true;
    });

    if (keyboardState.recentlyUsed.length && props.enableRecentlyUsed) {
      data.push({
        title: 'recently_used',
        data: keyboardState.recentlyUsed
      });
    }

    if (props.enableSearchBar) {
      data.push({
        title: 'search',
        data: _emojis.default.map(group => group.data).flat().filter(emoji => {
          if (searchPhrase.length < 2) return false;
          return emoji.name.toLowerCase().includes(searchPhrase.toLowerCase()) || emoji.emoji.toLowerCase().includes(searchPhrase);
        })
      });
    }

    if (props.categoryOrder) {
      const orderedData = props.categoryOrder.flatMap(name => data.filter(el => el.title === name));
      const restData = data.filter(el => {
        var _props$categoryOrder;

        return !(props !== null && props !== void 0 && (_props$categoryOrder = props.categoryOrder) !== null && _props$categoryOrder !== void 0 && _props$categoryOrder.includes(el.title));
      });
      data = [...orderedData, ...restData];
    }

    return data;
  }, [keyboardState.recentlyUsed, props.enableRecentlyUsed, props.enableSearchBar, props.categoryOrder, props.disabledCategories, searchPhrase]);
  const value = { ...defaultKeyboardContext,
    ...defaultKeyboardValues,
    ...props,
    activeCategoryIndex,
    setActiveCategoryIndex,
    numberOfColumns: numberOfColumns.current,
    width,
    searchPhrase,
    setSearchPhrase,
    renderList
  };
  return /*#__PURE__*/React.createElement(_KeyboardContext.KeyboardContext.Provider, {
    value: value
  }, props.children);
});
exports.KeyboardProvider = KeyboardProvider;
KeyboardProvider.displayName = 'KeyboardProvider';
//# sourceMappingURL=KeyboardProvider.js.map